# 记忆功能使用示例

## 快速开始

### 步骤 1: 第一次运行
```bash
python app_first.py
```

**预期输出:**
```
=== 第一次运行 ===
发送消息: I have 2 dogs in my house.
AI回复: That's great! Dogs make wonderful companions...

保存记忆 - user: I have 2 dogs in my house.
保存记忆 - model: That's great! Dogs make wonderful companions...

✅ 对话历史已保存到 chat_history.json
现在可以运行 app_second.py 继续对话
```

### 步骤 2: 第二次运行
```bash
python app_second.py
```

**预期输出:**
```
=== 第二次运行 ===
正在加载对话记忆...
✅ 成功加载 2 条历史记录

正在恢复对话上下文...
已恢复记忆 1: I have 2 dogs in my house.

=== 继续对话 ===
发送消息: How many paws are in my house?
AI回复: With 2 dogs in your house, you have 8 paws! Each dog has 4 paws...

=== 完整对话历史 ===
user: I have 2 dogs in my house.
--------------------------------------------------
model: That's great! Dogs make wonderful companions...
--------------------------------------------------
user: How many paws are in my house?
--------------------------------------------------
model: With 2 dogs in your house, you have 8 paws!...
--------------------------------------------------

✅ 更新后的对话历史已保存
```

## 工作原理

### 记忆保存机制
```python
# 1. 获取对话历史
history = chat.get_history()

# 2. 转换为可保存的格式
history_data = []
for message in history:
    message_dict = {
        "role": message.role,      # "user" 或 "model"
        "content": message.parts[0].text
    }
    history_data.append(message_dict)

# 3. 保存到JSON文件
with open("chat_history.json", "w", encoding="utf-8") as f:
    json.dump(history_data, f, ensure_ascii=False, indent=2)
```

### 记忆恢复机制
```python
# 1. 加载历史记录
with open("chat_history.json", "r", encoding="utf-8") as f:
    history_data = json.load(f)

# 2. 创建新会话
chat = client.chats.create(model="gemini-2.5-flash")

# 3. 重新发送用户消息来恢复上下文
for msg in history_data:
    if msg["role"] == "user":
        chat.send_message(msg["content"])
```

## 查看保存的记忆

打开 `chat_history.json` 文件:
```json
[
  {
    "role": "user",
    "content": "I have 2 dogs in my house."
  },
  {
    "role": "model",
    "content": "That's great! Dogs make wonderful companions..."
  }
]
```

## 进阶使用

### 清空记忆重新开始
```bash
# 删除历史文件
rm chat_history.json

# 重新运行第一次
python app_first.py
```

### 编辑记忆内容
你可以直接编辑 `chat_history.json` 来修改历史对话内容,实现自定义的对话上下文。

### 多轮对话
可以创建 `app_third.py`、`app_fourth.py` 等文件,持续积累记忆:
```python
# app_third.py 的结构
# 1. 加载 chat_history.json
# 2. 恢复对话上下文
# 3. 发送新消息
# 4. 更新 chat_history.json
```

## 应用到社会模拟器

这个记忆功能可以应用到项目的NPC系统中:

### NPC记忆系统设计
```python
class NPCWithMemory:
    def __init__(self, name):
        self.name = name
        self.memory_file = f"memory_{name}.json"
    
    def save_memory(self):
        # 保存NPC的对话历史和经历
        pass
    
    def load_memory(self):
        # 加载NPC的记忆
        pass
```

### 应用场景
1. **长期记忆**: NPC记住之前的互动和冲突
2. **关系发展**: 基于历史互动改变对其他角色的态度
3. **学习行为**: 根据过去的经验调整行为策略
4. **情节连续性**: 跨多次运行保持故事连续性

## 常见问题

### Q1: 为什么需要重新发送用户消息来恢复上下文?
A: Gemini API 需要完整的对话历史来维持上下文。通过重新发送用户消息,AI可以"回忆"起之前的对话内容。

### Q2: 记忆文件会占用多少空间?
A: 每条消息大约占用 50-200 字节。即使是长对话,也不会占用太多空间。

### Q3: 可以保存多个不同的对话吗?
A: 可以!只需要使用不同的文件名:
```python
# 对话1
with open("chat_history_1.json", "w") as f:
    json.dump(history_data, f)

# 对话2  
with open("chat_history_2.json", "w") as f:
    json.dump(history_data, f)
```

### Q4: 记忆会失效吗?
A: 只要 `chat_history.json` 文件存在且格式正确,记忆就会一直有效。

## 总结

✅ **简单易用**: 两个文件,两步操作
✅ **完整记忆**: AI能完全记住之前的对话
✅ **灵活扩展**: 可以应用到更复杂的场景
✅ **透明可控**: 记忆内容保存在可编辑的JSON文件中

现在你已经掌握了如何让AI拥有记忆能力!


